# 코딩 테스트를 위한 파이썬 문법

- 파이썬은 코드가 짧은 편
- 코딩 테스트에서 중요한 내용 위주로 수록
- 코딩 테스트용 코드는 함수만으로 문제풀이에 필요한 기능을 모듈화하는 경우가 많음
- 클래스와 같은 문법을 제외하고 코딩 테스트 합격에 필요한 문법 위주로 소개

## 1. 자료형

- 자료형에 대한 이해는 프로그래밍의 길에 있어서 첫걸음

### 1.1. 수 자료형

- 코딩 테스트에서 가장 기본적인 자료형
- 실제 코딩 테스트에서는 대부분 정수형을 다루는 문제가 출제
- 실수형을 다루는 문제는 출제 빈도가 낮음

#### 1.1.1. 정수형

- 정수를 다루는 자료형: 양의 정수, 음의 정수, 0
- 코딩 테스트의 알고리즘 문제는 대부분 입력과 출력 데이터가 정수형

```python
a = 1000 # 양의 정수
b = -7   # 음의 정수
c = 0    # 0
```

#### 1.1.2. 실수형

- 소수점 아래의 데이터를 포함하는 수 자료형
- 파이썬은 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리
- 소수부나, 정수부가 9인 실수는 0을 생략할 수 있음

```python
a = 157.93  # 양의 실수
b = -1837.2 # 음의 실수
c = 5.      # 소수부 0을 생략한 실수
d = -.7     # 정수부 0을 생략한 실수
```

`e`나 `E`를 이용한 지수 표현 방식: e 다음에 오는 수는 10의 지수부

> `1e9` == 10의 9제곱 == 1,000,000,000
>
> 유효숫자e<sup>지수</sup> = 유효숫자 × 10<sup>지수</sup>

지수 표현 방식은 코딩 테스트에서 많이 사용된다.

1. 최단 경로로 가능한 최댓값이 10억 미만이라면 무한(INF) 표현에 10억(`1e9`)을 사용할 수 있음
1. 큰수를 표현할 때 10억을 코드에 직접 입력하기 보다는 `1e9`로 표현하여 실수를 방지

> 큰수 표현시 `987,654,321`을 이용해 `1e9`와 유사한 큰수를 사용하기도 한다.

```python
a = 1e9     # 1000000000.0
b = 752.5e1 # 752.5
c = 3954e-3 # 3.954
```

부동소수점 문제(issue)

- 오늘날 가장 널리 쓰이는 IEEE754 표준에서는 실수형 저장에 4바이트 또는 8바이트 고정 크기의 메모리를 할당
- 이로 인해 현대 컴퓨터 시스템은 실수 정보 표현의 정확도에 한계가 있음
- 2진수에서는 `0.3`과 `0.6`을 더한 값인 `0.9`를 정확히 표현할 수 없음

```python
a = 0.3 + 0.6  # 0.8999999999999999

if a == 0.9
  print(True)
else
  print(False) # False
```

소수점 값을 비교할 경우 `round()` 함수 이용

> round(실수형 데이터, 반올림하고자 하는 위치 - 1)

```python
round(123.456, 2)      # 123.46
```

- 코딩 테스트에서는 실수형 데이터를 비교할 때 소수점 다섯 번째 자리에서 반올림한 결과가 같으면 정답으로 인정하는 식으로 처리

```python
a = 0.3 + 0.6

if round(a, 4) == 0.9:
  print(True)          # True
else
  print(False)
```

#### 1.1.3. 수 자료형의 연산

- 사칙연산: `+`, `-`, `×`, `/`
- 사칙연산 중 `/` 사용시 주의할 점: 나눠진 결과를 기본적으로 실수형으로 처리
- 나머지연산자: `%`
- 몫 연산자: `//`. 나눠진 결과에서 몫만을 얻고자 할 때 사용
- 거듭제곱 연산자: `**`

```python
a = 7
b = 3

print(a / b)  # 2.3333333333333335
print(a % b)  # 1
print(a // b) # 2

a = 5
b = 3
print(a ** b) # 125
```

### 1.2. 리스트 자료형

#### 1.2.1. 리스트 만들기

- 대괄호(`[]`)안에 원소를 넣어 초기화하며, 쉼표(`,`)로 원소를 구분
- 리스트 원소에 접근할 때는 인덱스(index) 값을 괄호 안에 넣음
- 인덱스는 `0`부터
- 빈 리스트 선언시 `list()` 혹은 `[]` 사용 가능

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a)    # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 인덱스 4에 접근
print(a[4]) # 5

# 빈 리스트 선언
a = list()
print(a)   # []
a = []
print(a)   # []
```

코딩 테스트에서 주로 크기가 N인 1차원 리스트를 초기화해야 하는데 다음 방식으로 초기화 하면 편리하다.

```python
# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
n = 10
a = [0] * n
print(a)    # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

#### 1.2.2. 리스트의 인덱싱과 슬라이싱

- 인덱싱(Indexing): 인덱스값을 입력하여 리스트의 특정 원소에 접근하는 것
- 파이썬의 인덱스 값은 양의 정수와 음의 정수 모두 사용 가능(음의 정수는 원소를 거꾸로 탐색)

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[-1])                    # 9
print(a[-3])                    # 7
a[3] = 7
print(a)                        # [1, 2, 3, 7, 5, 6, 7, 8, 9]
```

- 슬라이싱(Slicing): 리스트에서 연속적인 위치를 갖는 원소들을 가져올 때 이용
- 대괄호 안에 콜론(`:`)을 넣어서 시작 인덱스와 끝 인덱스(-1)을 설정할 수 있음

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[1:4])                   # [2, 3, 4]
```

#### 1.2.3. 리스트 컴프리헨션

- 리스트 컴프리헨션: 리스트를 초기화하는 방법 중 하나
- 대괄호 안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화 할 수 있음

```python
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
array = [i for i in range(20) if i % 2 == 1]
print(array)                               # [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
```

위 코드를 일반 문법으로 작성하면 아래와 같다.

```python
array = []
for i in range(20):
  if i % 2 == 1:
    array.append(i)

print(array)
```

```python
# 1부터 9까지의 수의 제곱 값을 포함하는 리스트
array = [i * i for in range(1, 10)]
print(array)                        # [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

코딩 테스트에 2차원 리스트를 초기화할 때 매우 효과적으로 사용 가능

```python
# N × M 크기의 2차원 리스트 초기화
n = 3
m = 3
array = [[0] * m for _ in range(n)]
print(array) # [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

특정 크기의 2차원 리스트를 초기화 할 때는 반드시 리스트 컴프리헨션을 이용해야 한다.

```python
# N × M 크기의 2차원 리스트 초기화(잘못된 방법)
n = 3
m = 4
array = [[0] * n] * m
print(array) # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]

array = [1][1] = 5
print(array) # [[0, 5, 0], [0, 5, 0], [0, 5, 0], [0, 5, 0]]
```

내부적으로 포함된 4개의 리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식되어 오류가 발생한다.

#### 1.2.4. 리스트 관련 기타 메서드

주요 함수표

| 함수명      | 사용법            | 설명                               | 시간 복잡도 |
|-----------|------------------|-----------------------------------|----------|
| append()  | `변수명.append()` | 리스트에 원소를 하나 삽입                    | O(1) |
| sort()    | `변수명.sort()`  | 기본 정렬 기능으로 오름차순 정렬           | O(NlogN) |
|           | `변수명.sort(reverse=True)` | 내림차순 정렬               | O(NlogN) |
| reverse() | `변수명.reverse()` | 리스트 원소의 순서를 모두 뒤집음             | O(N) |
| insert()  | `insert(삽입할 위치 인덱스, 삽입값)` | 특정 인덱스 위치에 원소를 삽입 | O(N) |
| count()   | `변수명.count(특정값)` | 리스트에서 특정값ㅇ르 갖는 데이터의 개수 반환 | O(N) |
| remove()  | `변수명.remove(특정값)` | 특정값을 갖는 원소를 하나만 제거          | O(N) |

```python
a = [1, 4, 3]
print("기본 리스트: ", a)                   # 기본 리스트: [1, 4, 3]

# 리스트에 원소 삽입
a.append(2)
print("삽입: ", a)                        # 삽입: [1, 4, 3, 2]

# 오름차순 정렬
a.sort()
print("오름차순 정렬: ", a)                 # 오름차순 정렬: [1, 2, 3, 4]

# 내림차순 정렬
a.sort(reverse = True)
print("내림차순 정렬: ", a)                 # 내림차순 정렬: [4, 3, 2, 1]

# 리스트 원소 뒤집기
a.reverse()
print("원소 뒤집기: ", a)                  # 원소 뒤집기: [1, 2, 3, 4]

# 특정 인덱스에 데이터 추가
a.insert(2, 3)
print("인덱스 2에 3 추가: ", a)            # 인덱스 2에 3 추가: [1, 2, 3, 3, 4]

# 특정값인 데이터 개수 세기
print("값이 3인 데이터 개수: ", a.count(3)) # 값이 3인 데이터 개수: 2

# 특정값 데이터 삭제
a.remove(1)
print("값이 1인 데이터 삭제: ", a)          # 값이 1인 데이터 삭제 [2, 3, 3, 4]
```

`insert()`, `append()`, `remove()`

- `insert()`: 원소의 개수가 N개면, 시간 복잡도는 O(N). 원소 삽입 후, 리스트의 원소 위치를 조정하기 때문에 남발하면 '시간 초과'가 될 수 있음
- `append()`: O(1)로 수행됨
- `remove()`: `insert()`와 마찬가지로 O(N)

특정한 값의 원소를 모두 제거할 경우 아래의 방법을 이용한다.

```python
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = [3, 5]

# remove_set에 포함되지 않은 값만 저장
result = [i for i in a if i not in remove_set]
print(result)                                  # [1, 2, 4]
```

### 1.3. 문자열 자료형

#### 1.3.1. 문자열 초기화

- 문자열 변수 초기화에는 큰따옴표(`"`)와 작은따옴표(`'`) 이용
- 큰따옴표와 작은따옴표는 내부에 각각 작은따옴표와 큰따옴표를 사용할 수 있음
- 이스케이프 문자(`\`)를 이용해서 큰따옴표나 작은따옴표를 문자열에 포함시킬 수 있음

```python
data = 'Hello World'
print(data)                         # Hello World

data = "don't you know \"Python\"?"
print(data)                         # don't you know "Python"?
```

#### 1.3.2. 문자열 연산

- 덧셈(`+`)을 이용해 문자열을 연결할 수 있음
- 문자열 변수를 양의 정수와 곱하여 문자열을 반복할 수 있음

```python
a = "Hello"
b = "World"

print(a + " " + b) # Hello World

a = "String"
print(a * 3)       # StringStringString
```

- 파이썬의 문자열은 내부적으로 리스트처럼 처리됨
- 문자열은 여러 개의 문자가 합쳐진 리스트라고 볼 수 있음
- 문자열 데이터에도 인덱싱과 슬라이싱을 할 수 있음

```python
a = "ABCDEF"
print(a[2 : 4]) # CD
```

### 1.4. 튜플 자료형

- 리스트와 유사하지만 확실한 차이점이 있음
- 한 번 선언된 값을 변경할 수 없음
- 튜플은 소괄호(`()`)를 이용

```python
a = (1, 2, 3, 4)
print(a)         # (1, 2, 3, 4)
a[2] = 7
                 # Traceback (most recent call last):
                 #  File "<stdin>", line 1, in <module>
                 # TypeError: 'tuple' object does not support item assignment
```

- 그래프 알고리즘을 구현할 때 자주 사용
- 다익스트라 알고리즘 등 최단 경로 알고리즘에서는 우선순위 큐를 활용하는데 큐에 한 번 들어간 값은 불변
- 변경되면 안되는 값을 변경하는 경우를 체크할 수 있음
- 리스트에 비해 공간 효율성이 좋음
- 각 원소의 성질이 서로 다를 때 주로 사용
- 예: 다익스트라 알고리즘에서 서로 다른 성질의 데이터를 `(비용, 노드 번호)` 형태로 묶어 관리함

### 1.5. 사전 자료형

#### 1.5.1. 사전 자료형 소개

- 키(key)와 값(value)의 쌍을 데이터로 갖는 자료형
- 변경 불가능한 데이터를 키로 사용할 수 있음
- 사전 자료형은 내부적으로 해시 테이블(Hash Table)을 이용, O(1)의 시간복잡도
- 키-값 쌍으로 구성된 데이터를 처리하는데 리스트보다 훨씬 빠르게 동작할 수 있음

> 변경 불가능한 자료형: 수, 문자열, 튜플 자료형처럼 한 번 초기화되면 변경이 불가능한 자료형을 의미한다. 튜플 자료형이 사전 자료형의 키로 사용되기도 하는데 이는 "Q22. 블록 이동하기"에서 사용됨

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

print(data)             # {'바나나': 'Banana', '사과': 'Apple', '코코넛': 'Coconut'}
```

- 사전 자료형은 코딩 테스트에서 자주 사용됨
- 학생의 번호가 1~10,000,000인 경우에 10,000명의 학생이 선택됐을 때 10,000개의 데이터만 사전 자료형에 대입하면 훨씬 적은 메모리 공간을 사용할 수 있음
- 사전 자료형의 조회는 '원소 in 사전' 형태를 사용하며 리스트와 튜플에서도 사용 가능한 문법

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

if '사과' in data:
  printf("사과를 키로 갖는 데이터가 존재합니다.") # 사과를 키로 갖는 데이터가 존재합니다.
```

#### 1.5.2. 사전 자료형 관련 함수

- `keys()`: 키 데이터만 뽑아서 리스트로 이용
- `values()`: 값 데이터만 뽑아서 리스트로 이용

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

# 키 데이터만 담은 리스트
key_list = data.keys()
# 값 데이터만 담은 리스트
value_list = data.values()
print(key_list)            # ['사과', '바나나', '코코넛']
print(value_list)          # ['Banana', 'Apple', 'Coconut']

# 각 키에 따른 값을 하나씩 출력
for key in key_list:
  print(data[key])         # Apple
                           # Banana
                           # Coconut
```

### 1.6. 집합 자료형

집합 자료형 소개

집합 자료형의 연산

집합 자료형 관련 함수

## 2. 조건문

### 2.1. 비교 연산자

### 2.2. 논리 연산자

### 2.3. 파이썬의 기타 연산자

## 3. 반복문

### 3.1. while문

### 3.2. for문

## 4. 함수

## 5. 입출력

## 6. 주요 라이브러리의 문법과 유의점

### 6.1. 내장 함수

### 6.2. itertools

### 6.3. heapq

### 6.4. bisect

### 6.5. collections

### 6.6. math

## 7. 자신만의 알고리즘 노트 만들기
